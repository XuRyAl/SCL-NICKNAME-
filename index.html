<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Polygon Growth Animation</title>
<style>
  canvas {
    background: #f0f0f0;
    display: block;
    margin: 0 auto;
  }
</style>
</head>
<body>
<canvas id="canvas" width="600" height="600"></canvas>
<script>
// Get canvas and context
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// Initialize polygon (triangle)
let polygon = [
  {x: 300, y: 150},
  {x: 150, y: 450},
  {x: 450, y: 450}
];

// Ball properties
let ball = {
  x: 300,
  y: 300,
  radius: 8,
  vx: 2,
  vy: -2,
  speedMultiplier: 1
};

// Function to draw polygon
function drawPolygon(points) {
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i=1; i<points.length; i++) {
    ctx.lineTo(points[i].x, points[i].y);
  }
  ctx.closePath();
  ctx.strokeStyle = 'blue';
  ctx.lineWidth = 2;
  ctx.stroke();
}

// Function to draw ball
function drawBall() {
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI *2);
  ctx.fillStyle = 'red';
  ctx.fill();
}

// Function to update ball position
function update() {
  // Move ball
  ball.x += ball.vx * ball.speedMultiplier;
  ball.y += ball.vy * ball.speedMultiplier;

  // Check collision with polygon sides
  for (let i=0; i<polygon.length; i++) {
    const p1 = polygon[i];
    const p2 = polygon[(i+1)%polygon.length];

    if (checkLineCircleCollision(p1, p2, ball)) {
      // Reverse direction (simple bounce)
      reflectBall(p1, p2);
      // Increase speed
      ball.speedMultiplier += 0.2;

      // Add a new side to the polygon
      addSideToPolygon(p1, p2);
      
      break; // Only handle one collision per frame
    }
  }

  // Keep ball inside canvas bounds
  if (ball.x + ball.radius > canvas.width || ball.x - ball.radius <0) {
    ball.vx *= -1;
  }
  if (ball.y +ball.radius > canvas.height || ball.y - ball.radius <0) {
    ball.vy *= -1;
  }
}

// Function to check collision between circle and line segment
function checkLineCircleCollision(p1, p2, circle) {
  // Closest point on line segment to circle center
  const A = {x: p1.x, y: p1.y};
  const B = {x: p2.x, y: p2.y};
  const C = {x: circle.x, y: circle.y};
  
  const AB = {x: B.x - A.x, y: B.y - A.y};
  const AC = {x: C.x - A.x, y: C.y - A.y};
  
  const abLengthSq = AB.x*AB.x + AB.y*AB.y;
  const t = Math.max(0, Math.min(1, (AC.x*AB.x + AC.y*AB.y) / abLengthSq));
  
  const closest = {x: A.x + AB.x * t, y: A.y + AB.y * t};
  const distSq = (closest.x - C.x)**2 + (closest.y - C.y)**2;
  
  return distSq <= circle.radius**2;
}

// Function to reflect ball velocity upon collision
function reflectBall(p1, p2) {
  // Compute normal vector of the side
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  const length = Math.hypot(dx, dy);
  const normal = {x: -dy/length, y: dx/length};

  // Dot product of velocity and normal
  const dot = ball.vx * normal.x + ball.vy * normal.y;

  // Reflect velocity
  ball.vx = ball.vx - 2 * dot * normal.x;
  ball.vy = ball.vy - 2 * dot * normal.y;

  // Slightly move ball outside the collision to prevent sticking
  ball.x += normal.x;
  ball.y += normal.y;
}

// Function to add a new side to the polygon
function addSideToPolygon(p1, p2) {
  // For simplicity, add a new point slightly outside the midpoint of the collided side
  const midX = (p1.x + p2.x)/2;
  const midY = (p1.y + p2.y)/2;
  
  // Compute a perpendicular vector
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  const length = Math.hypot(dx, dy);
  const perp = {x: -dy/length, y: dx/length};

  // Add new point outside the side
  const newPoint = {
    x: midX + perp.x *50,
    y: midY + perp.y *50
  };

  // Insert new point into polygon
  // Find index of p2 to insert after p1
  const index = polygon.indexOf(p2);
  polygon.splice(index, 0, newPoint);
}

// Animation loop
function animate() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawPolygon(polygon);
  update();
  drawBall();
  requestAnimationFrame(animate);
}

// Start animation
animate();
</script>
</body>
</html>
